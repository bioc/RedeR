%\VignetteIndexEntry{Main vignette: RedeR Overview}
%\VignetteKeywords{Graph}
%\VignettePackage{RedeR}

\documentclass[11pt]{article}
\usepackage{Sweave,fullpage}
\usepackage{hyperref}
\bibliographystyle{unsrt}
\usepackage{subfig}

\title{RedeR: bridging the gap between hierarchical network representation and functional analysis.}
\author{
Mauro A. A. Castro, Xin Wang, Florian Markowetz 
\thanks{Cancer Research UK - Cambridge Research Institute, Robinson Way Cambridge, CB2 0RE, UK.} \\
\texttt{\small http://www.markowetzlab.org/software/networks.html} \\
\texttt{\small florian.markowetz@cancer.org.uk} \\
}

\begin{document}

\maketitle

\tableofcontents

<<Ropts, echo=FALSE, results=hide>>=
options(width=100)
@ 

\newpage 

\section{Overview}

\emph{RedeR} is an R-based package combined with a Java application for dynamic network visualization and manipulation. It
implements a callback engine by using a low-level R-to-Java interface to build and run common plugins. In this sense, \emph{RedeR} takes advantage of 
\emph{\textbf{R}} to run robust statistics, while the R-to-Java interface bridge the gap between network analysis and visualization: for \textbf{R Developers}, it allows 
the development of Java plug-ins exclusively using R codes; for \textbf{Java Users}, it runs R methods implemented in a stand-alone application,  
and for \textbf{R Users} \emph{RedeR} interactively displays R graphs using a robust Java graphic engine embedded in \emph{R}.  \\

\emph{RedeR} use different strategies to link R to Java: 

\begin{itemize}
    \item Data interface: implements the callback engine to make calls from R via xml-rpc protocol. It sets \emph{R} as client and \emph{RedeR} as server. 
    \item Graphic interface: implements the callback engine to make calls from Java via dynamic libraries. It wraps R graphics into RedeR classes. 
\end{itemize}

The design of the software is depicted from Figure 1. One unique feature of this concept is how R methods can be wrapped and exported. For example, in a few lines of code
\emph{RedeR} sends R methods to the Java app using the \emph{submitPlugin} function, which gives rise to a new Java plugin. Also, complex graphs with many attributes 
can be transferred from-and-to \emph{R} using \emph{addGraph} and \emph{getGraph} functions. \\


%%%%%%
%Fig1%
%%%%%%
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=1.0\textwidth]{fig1.pdf}
\end{center}
\label{fig1}
\caption{Schematic representation of RedeR calls. In the low-level interface, packages like XMLRPC\cite{XMLRPC} and rJava\cite{rJava} are used to link R to Java.}
\end{figure}

\section{Quick start}

\subsection{Main callback methods}

The first step is to build the server port, which will be required in all remote procedure calls. By default the constructor \emph{RedPort} should set all details:

\begin{small}
<<label=Main call, eval=TRUE>>=
   library (RedeR)
   rdp <- RedPort () 
@ 
\end{small}

Next, invoke RedeR using the method \emph{calld}:

\begin{small}
<<label=Main call, eval=FALSE>>=
   calld(rdp)
@ 
\end{small}

Within an active interface, then the method 'addGraph' can easily send R graphs to the application. For example, the following chunk adds an \emph{igraph}\cite{igraph} object:
\begin{small}
<<label= Add graph, eval= TRUE>>=
   g1 <- graph.lattice(c(5,5,5))
   addGraph( rdp, g1, layout.kamada.kawai(g1) )
@
\end{small}

%%%%%%
%Fig2%
%%%%%%
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.4\textwidth]{fig2.pdf}
\end{center}
\label{fig2}
\caption{A toy example added to \emph{RedeR} by the \emph{addGraph} function.}
\end{figure}


Conversely, RedeR graphs can be transferred to R and wrapped in \emph{igraph} objects:
\begin{small}
<<label= Get graph, eval= TRUE>>=
   g2 <- getGraph(rdp)
   resetd(rdp)
@
\end{small}
The interface accepts additional graph attributes, as for example edge direction, edge width, edge weight, node shape, node size, node color etc. In \emph{igraph} objects, vertex and edge attributes can be assigned as arbitrary R objects. In order to pass these extensible features to \emph{RedeR} the attributes must be provided in a valid syntax.
\footnote[1]{See \emph{getGraph} and \emph{addGraph} specification for additional details.}


Another strategy is to wrap graphs into containers and then send it to the Java app. Next, the subgraphs g3 and g4 are assigned to different nested structures (Fig.3).
\begin{small}
<<label= Build subgraphs, eval= TRUE>>=
   g3 <- barabasi.game(10)
   g4 <- barabasi.game(10)
   V(g3)$name<-paste("sn",1:10,sep="")
   V(g4)$name<-paste("sm",1:10,sep="")
   addGraph(rdp, g3, isNest =TRUE, gcoord=c(25,25), gscale=50)
   addGraph(rdp, g4, isNest =TRUE, gcoord=c(75,75), gscale=50 )
@
\end{small}

%%%%%%
%Fig3%
%%%%%%
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.8\textwidth]{fig3.png}
\end{center}
\label{fig3}
\caption{Graphs nested in \emph{RedeR} by the command \emph{addGraph}.}
\end{figure}


In this case, the subgraphs can be handled apart from each other. For example, the following chunk selects all nodes assigned to the container "N0" and then gets back the subgraph (the selection step can also be done interactively!).

\begin{small}
<<label= Get subgraph, eval= TRUE>>=
   selectNodes(rdp,"N0")
   g5 <- getGraph(rdp, status= "selected")
   resetd(rdp)
@
\end{small}

\emph{As a suggestion, try some RedeR features in the Java side (e.g. open samples s2 or s3 in the main panel and enjoy the dynamic layout options!).}


\newpage


\subsection{Working interactively}

The next chunk generates a scale-free graph according to the Barabasi-Albert model\cite{igraph} and sends the graph to RedeR without any layout information.
\begin{small}
<<label= Build scale-free graph and send to the app, eval= TRUE>>=
   g6 <- barabasi.game(500)
   addGraph(rdp, g6)
@
\end{small}

Then using the dynamic function available in the app you can layout the graph as presented in Figure 4.

%%%%%%
%Fig4%
%%%%%%
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.7\textwidth]{fig4.pdf}
\end{center}
\label{fig4}
\caption{Scale-free graph according to the Barabasi-Albert model\cite{igraph}.}
\end{figure}

In Figure 5a the same graph is used to exemplify the community structure mapped by the edge-betweenness function available in RedeR. In Figure 5b these communities are nested to containers, which are objects of the same class of the nodes but with additional behaviors: it can be hidden and anchored to the main panel (Fig.5c). You can build these containers either using \emph{R} or \emph{Java} functions (see options available in the \emph{clustering} main menu and in the shortcuts of nested objects).

%%%%%%
%Fig5%
%%%%%%
\begin{figure}[htbp]
  \centering
  \subfloat[Communities]{\label{fig5a: Communities}\includegraphics[width=.5\textwidth]{fig5a.pdf}}              
  \subfloat[Graphs into containers]{\label{fig5b:Graphs into containers}\includegraphics[width=.5\textwidth]{fig5b.png}} \\
   \subfloat[Subnetworks]{\label{fig5c:Subnetworks}\includegraphics[width=.9\textwidth]{fig5c.pdf}}
  \caption{Community structure: (a) subgraphs detected based on edge betweenness; (b) nested communities into containers; (c) subnetworks in hidden containers.}
\end{figure} 


For the next example you will need to reproduce in \emph{RedeR} app the graph from Figure 5b (or any graph with containers), then select one of the communities and run the chunk below:  a simple degree distribution should be plotted in the R side (Fig.6). This is the first step to illustrate how to build an interactive plugin.
\begin{small}
<<label= Map clic communities, eval= TRUE>>=
   g <- getGraph(rdp, status= "selected")
   if(vcount(g)>0)plot(degree.distribution(g), xlab = "k", ylab = "P(k)", pch=19)
@
\end{small}

\newpage

\subsection{Plugin builder}

RedeR plug-ins have two main sections: methods and add-ons. The 'methods' section can be regarded as the plug-in trigger. 
When installed in the Java app, this trigger is used to start a given analysis by unfolding the R expressions wrapped in the methods. 
Add-ons use the same strategy, but remains hidden in the app -- and it is optional. Formal functions can be passed to add-ons as additional arguments. 
Prior to the main call, all functions are automatically loaded in R, making the source code available to the subsequent analysis.\

\subsubsection*{A simple example} 

\begin{itemize}

\item Wrap methods in functions

Here, the degree distribution is used in the same way as illustrated in the previous section but -- prior to execute the analysis -- the plugin requires two commands: \emph{RedPort} to set the interface, and \emph{dynwin} to wrap R graphics in RedeR Java classes.
\begin{small}
<<label= Set a simple method, eval= TRUE>>=
      mt1 <- function() 
      {
  	rdp <- RedPort('MyPort')
  	dynwin(rdp)
   	g <- getGraph(rdp, status= "selected")
	if(vcount(g)>0)plot(degree.distribution(g), xlab = "k", ylab = "P(k)", pch=19)
       }
@
\end{small}

\item Initiate plugin skeleton:

Now the method \emph{mt1} is added to the \emph{PluginBuilder}, and is ready to be sent to the application.
\begin{small}
<<label= Build a plugin skeleton, eval= TRUE>>=
    plugin <- PluginBuilder(title="MyPlugin", allMethods=list(mt1=mt1))
@                             
\end{small}

\item Submit new plugins to RedeR:

The submission is straightforward: in the Java side, the plugin will be displayed in the main menu provided that the interface is properly set to find \emph{R}.
\begin{small}
<<label= Submit the plugin to RedeR app, eval= TRUE>>=
  submitPlugin(rdp, plugin)
  updatePlugins(rdp)
  exitd(rdp)
@
\end{small}

\end{itemize}

\emph{As a suggestion, try the heatmap plugin in RedeR. This is the first default plugin of the software; hopefully others will be available soon! }

%%%%%%
%Fig6%
%%%%%%
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\textwidth]{fig6.pdf}
\end{center}
\label{fig6}
\caption{RedeR plugins: a simple example to illustrate the concept (degree distribution of selected subgraphs). One subgraph from Figure 5b was interactively selected in \emph{RedeR} and then plotted either in the R side or in the Java side of the interface using the plugin described above.}
\end{figure}


\newpage 

\section{Installation}

\subsection{The RedeR package}
The RedeR package is freely available from Bioconductor at \url{http://www.bioconductor.org}.
In addition, you might need to install other dependencies (e.g. RCurl and XML; section 3.3 shows a typical R session).

\subsection{The RedeR application}
The RedeR jar file is already included in the R package and, as usual, to run Java applications your system must have a copy of the JRE (Java Runtime Environment, version>= 5). The RedeR software can be used as a stand-alone application, or even embedded in other softwares, but in order to use plugins the interface must be set properly in the Java side to find R (e.g. path to R home). This should be a simple task:
\begin{itemize}
\item Using RedeR embedded in R: it is automatic ..but if your R environment deviates a lot from the default installation then it might be necessary to add some path manually. 
The function \emph{calld} accepts additional arguments for these cases. 
\item Using RedeR as stand-alone application: follow the settings in the main menu and add R paths if required. A script file is generated to do all the job.
\end{itemize}

If you find any difficulty, please contact us.

\newpage


\subsection{Session information}

<<label=Session information, eval=TRUE,echo=FALSE>>=
print(sessionInfo(), locale=FALSE)
@

\newpage 

\bibliography{bib}


\newpage 

\newpage 

\section{Supplements}

The R chunks below can be used to reproduce the pre-processed dataset available in "RedeR.data" data object. 
This dataset integrates a case study that soon is going to appear in a new communication!

\begin{itemize}

\item Pre-processing pipelines for differential expression, clustering and co-expression analysis:

\begin{small}
<<label=Pre-processing pipelines, eval=FALSE>>=
source("casePart1.R")
deaPipeline()
deaFigures()
clustPipeline(nboot=1000)
clustFigures()
correl<-ceaPipeline()
ceaFigures(correl)
pvchip<-pvchipPipeline()
pvchipFigures(pvchip)
dataPipeline4RedeR(correl,pvchip)
graphPipeline4RedeR()
@
p.s.1 source 'casePart1.R' is  available in the package 'script' directory.\\
p.s.2 requirements: RedeR, limma, snow, pvclust and gplots packages.\\
p.s.3 Snow package might need adjustments to run parallel computing!
\end{small}

\item Pre-processing pipelines for enrichment analyses and subnetwork identification

\begin{small}
<<label=Pre-processing pipelines, eval=FALSE>>=
source("casePart2.R")
analysesPipeline()
gscoPipeline4RedeR()
ppiPipeline4RedeR()
@
p.s.1 source 'casePart2.R' is  available in the package 'script' directory.\\
p.s.2 requirements: RedeR, BioNet, DLBCL, ALL, limma, graph, org.Hs.eg.db, KEGG.db, GO.db, AnnotationDbi, snow, biomaRt and HTSanalyzeR packages.\\
p.s.3 Snow package might need adjustments to run parallel computing!
\end{small}

\end{itemize}

\end{document}
